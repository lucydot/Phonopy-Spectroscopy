{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Phonopy-Spectroscopy","text":"<p>Welcome to the documentation site for <code>Phonopy-Spectroscopy</code>.</p> <p><code>Phonopy-Spectroscopy</code> adds the capability to simulate vibrational spectra to the Phonopy code.</p> <p>The software consists of a Python package, <code>phonopy_spectroscopy</code>, and command-line scripts for performing typical calculations. It is hosted on the Phonopy-Spectroscopy Github Repository and is available to use and adapt under the open-source MIT License.</p>"},{"location":"#recent-upgrades-september-2025","title":"Recent upgrades (September 2025)","text":"<ul> <li>The \"backend\" Python API has been completely rewritten with a new object model.</li> <li>The infrared (IR) capability has been rewritten around computing the IR dielectric function, with options to account for different measurement geometries including powder averaging.</li> <li>The Raman capability has been expanded to include complete functionality for simulating single-crystal and powder Raman experiments, including with energy-dependent Raman tensors.</li> <li>Unit tests have been implemented with reasonable code coverage.</li> <li>The command-line programs and associated API have been temporarily removed pending a rewrite.</li> </ul>"},{"location":"#documentation-content","title":"Documentation content","text":"<ul> <li><code>Getting Started</code> - Installing Phonopy Spectroscopy and basic usage</li> <li><code>Tutorials</code> - Tutorials demonstrating Phonopy Spectroscopy functionality</li> <li><code>Reference</code> - Class and function level documentation</li> <li><code>Background</code>  - Background theory and formulations</li> <li><code>Development</code> - Contributing to Phonopy Spectroscopy or reporting problems</li> <li><code>Credit</code> - People and projects associated with Phonopy Spectroscopy</li> </ul>"},{"location":"credit/","title":"Credit","text":"<p><code>Phonopy-Spectroscopy</code> is developed by the Skelton Research Group at the University of Manchester, UK.</p>"},{"location":"credit/#citation","title":"Citation","text":"<p>Paper(s) on the new implementation and code are planned in the very near future. For now, the citation for the previous version of <code>Phonopy-Spectroscopy</code> is:</p> <p>J. M. Skelton, L. A. Burton, A. J. Jackson, F. Oba, S. C. Parker and A. Walsh, \"Lattice dynamics of the tin sulphides SnS<sub>2</sub>, SnS and Sn<sub>2</sub>S<sub>3</sub>: vibrational spectra and thermal transport\", Physical Chemistry Chemical Physics 19, 12452 (2017), DOI: 10.1039/C7CP01680H (open access)</p> <p>If you use Phonopy-Spectroscopy in your work, please consider citing this paper and/or including a link to this GitHub repository when you publish your results.</p>"},{"location":"credit/#projects-using-phonopy-spectroscopy","title":"Projects using <code>Phonopy-spectroscopy</code>.","text":"<p>TODO: project list.</p>"},{"location":"development/","title":"Development","text":"<p>Please use the Github issue tracker for feature requests and bug reports.</p> <p>We welcome contributions from the community; if you would like to contribute please contact us via the Github issue tracker. </p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The code requires a typical scientific computing Python stack with the <code>Numpy</code>, <code>SciPy</code>, <code>Pandas</code>, <code>PyYaml</code> and <code>H5py</code> packages. The Phonopy interface additionally requires the <code>Phonopy</code> Python library.</p> <p>If you are new to Python, we recommend using [Anaconda]((https://www.anaconda.com) (or Miniconda) and installing the required packages in a virtual environment:</p> <pre><code>% conda create -n phonopy-spectroscopy\n% conda activate phonopy-spectroscopy\n% conda install -c conda-forge phonopy pandas\n</code></pre>"},{"location":"installation/#phonopy-spectroscopy","title":"Phonopy-Spectroscopy","text":"<p>This code does not currently ship with a <code>setup.py</code> script or as a PIP/Conda package. This is planned for the near future.</p> <p>After cloning or downloading and unpacking the repository, add the <code>lib</code> subfolder to your <code>PYTHONPATH</code>, e.g.:</p> <p><code>export PYTHONPATH=${PYTHONPATH}:/Users/user/Desktop/Repositories/Phonopy-Spectroscopy/lib</code></p>"},{"location":"installation/#verifying-your-installation","title":"Verifying your installation","text":"<p>If you wish, you can run some of the <code>test_*.py</code> files in the <code>/tests</code> subfolder to check your installation is working.</p>"},{"location":"reference/phonon/","title":"phonon","text":"<p>Class for storing and working with phonon calculations.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons","title":"<code>GammaPhonons</code>","text":"<p>Class for storing and working with a Gamma-point phonon calculation.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>class GammaPhonons:\n    \"\"\"Class for storing and working with a Gamma-point phonon\n    calculation.\"\"\"\n\n    def __init__(self, struct, freqs, evecs, lws=None, irreps=None):\n        r\"\"\"Create a new instance of the `GammaPhonons` class.\n\n        Parameters\n        ----------\n        struct : Structure\n            Crystal structure.\n        freqs : array_like\n            Phonon frequencies in THz (shape: `(3N,)`).\n        evecs : array_like\n            Phonon eigenvectors in mass-weighted units of sqrt(amu)\n            (shape: `(3N, N, 3)`).\n        lws : array_like or None, optional\n            Phonon linewidths in THz (shape: `(3N,)`) or `None`.\n        irreps : Irreps or None, optional\n            `Irreps` object specifying the point group and assigning\n            bands to irrep groups.\n        \"\"\"\n\n        n_a = struct.num_atoms\n\n        if n_a == 0:\n            raise ValueError(\n                'struct cannot be \"empty\" and must contain at least one atom.'\n            )\n\n        freqs = np_asarray_copy(freqs, dtype=np.float64)\n\n        if not np_check_shape(freqs, (3 * n_a,)):\n            raise ValueError(\"freqs must be an array_like with shape (3N,).\")\n\n        evecs = np_asarray_copy(evecs, dtype=np.float64)\n\n        if not np_check_shape(evecs, (3 * n_a, n_a, 3)):\n            raise ValueError(\n                \"evecs must be an array_like with shape (3N, N, 3).\"\n            )\n\n        # Eigenvectors are in general complex, but Gamma-point\n        # eigenvectors must be real.\n\n        if np.iscomplex(evecs).any():\n            if (np.abs(evecs.imag) &gt; ZERO_TOLERANCE).any():\n                raise ValueError(\"Gamma-point eigenvectors should be real.\")\n\n            evecs = evecs.real\n\n        if lws is not None:\n            lws = np_asarray_copy(lws, dtype=np.float64)\n\n            if not np_check_shape(lws, (3 * n_a,)):\n                raise ValueError(\n                    \"If supplied, lws must be an array_like with shape (3N,).\"\n                )\n\n            if (lws &lt; 0.0).any():\n                raise ValueError(\"Linewidths cannot be negative.\")\n\n        if irreps is not None:\n            ir_band_inds_flat = irreps.band_indices_flat()\n\n            if len(ir_band_inds_flat) != 3 * n_a:\n                raise ValueError(\n                    \"If supplied, irreps must assign all bands to \"\n                    \"irrep groups.\"\n                )\n\n            if ir_band_inds_flat.max() &gt;= (3 * n_a):\n                raise RuntimeError(\n                    \"One or more band indices in irreps are not \"\n                    \"compatible with the number of modes in the \"\n                    \"phonon calculation.\"\n                )\n\n        self._struct = struct\n        self._freqs = freqs\n        self._evecs = evecs\n        self._lws = lws\n        self._irreps = irreps\n\n    @property\n    def structure(self):\n        \"\"\"Structure : Crystal structure.\"\"\"\n        return self._struct\n\n    @property\n    def frequencies(self):\n        \"\"\"numpy.ndarray : Phonon frequencies (shape: `(3N,)`).\"\"\"\n        return np_readonly_view(self._freqs)\n\n    @property\n    def eigenvectors(self):\n        \"\"\"numpy.ndarray : Phonon eigenvectors (shape: `(3N, N, 3)`).\"\"\"\n        return np_readonly_view(self._evecs)\n\n    @property\n    def linewidths(self):\n        \"\"\"numpy.ndarray or None : Phonon linewidths (shape: `(3N,)`).\"\"\"\n        return np_readonly_view(self._lws) if self._lws is not None else None\n\n    @property\n    def num_modes(self):\n        \"\"\"int : Number of modes.\"\"\"\n        return len(self._freqs)\n\n    @property\n    def has_linewidths(self):\n        \"\"\"bool : `True` if linewidths are available, otherwise `False`.\"\"\"\n        return self._lws is not None\n\n    @property\n    def has_irreps(self):\n        \"\"\"bool : `True` if irredicuble representations (irreps) are\n        available, otherwise `False`.\n        \"\"\"\n        return self._irreps is not None\n\n    @property\n    def irreps(self):\n        \"\"\"Irreps or None : `Irreps` object with the point group and\n        irrep symbols and indices of band groups.\"\"\"\n        return self._irreps\n\n    def get_acoustic_mode_indices(self):\n        \"\"\"Return the band indices of the acoustic modes.\n\n        Returns\n        -------\n        band_inds : numpy.ndarray\n            Band indices of the acoustic modes.\n        \"\"\"\n\n        # If we have irreps, select irrep group(s) for which the\n        # average frequency is closest to f = 0 until we have chosen\n        # sufficient groups to cover three modes.\n\n        if self._irreps is not None:\n            ir_ave_freqs = [\n                np.mean(self._freqs[band_inds])\n                for band_inds in self._irreps.irrep_band_indices\n            ]\n\n            subset_band_inds = []\n\n            for _, band_inds in sorted(\n                zip(ir_ave_freqs, self._irreps.irrep_band_indices)\n            ):\n                subset_band_inds.extend(band_inds)\n\n                if len(subset_band_inds) == 3:\n                    return np.array(subset_band_inds, dtype=int)\n\n            raise RuntimeError(\n                \"Unable to select a set of acoustic modes spanning \"\n                \"complete irrep groups. This may indicate an issue \"\n                \"with the phonon calculation.\"\n            )\n\n        # If not, find the three modes with frequencies closest to\n        # f = 0.\n\n        return np.argsort(np.abs(self._freqs))[:3]\n\n    def eigendisplacements(self):\n        r\"\"\"Return the phonon eigendisplacements (eigenvectors divided\n        by sqrt(mass)).\n\n        Returns\n        -------\n        edisps : numpy.ndarray\n            Eigendisplacements (shape: `(3N, N, 3)`).\n        \"\"\"\n\n        sqrt_m = np.sqrt(self._struct.atomic_masses)\n        return self._evecs / sqrt_m[np.newaxis, :, np.newaxis]\n\n    def hessian(self):\n        r\"\"\"Calculate the Hessian matrix (force constants) for the\n        Gamma-point phonon modes.\n\n        Returns\n        -------\n        h : numpy.ndarray\n            Hessian in eV / Ang^2 (shape: `(3N, 3N)`).\n\n        Notes\n        -----\n        This function requires the `phonopy` package.\n        \"\"\"\n\n        if not _PHONOPY_AVAILABLE:\n            raise RuntimeError(\n                \"GammaPhonons.hessian() requires the \"\n                \"phonopy.Phonopy and phonopy.phonon.DynmatToFc class.\"\n            )\n\n        n_a = self._struct.num_atoms\n\n        evals = np.copysign((self._freqs / VASP_TO_THZ) ** 2, self._freqs)\n\n        evec_mat = np.zeros((3 * n_a, 3 * n_a), dtype=np.complex128)\n\n        for i, evec in enumerate(self._evecs):\n            evec_mat[:, i].real = evec.flat\n\n        # Construct a Phonopy object to obtain the primitive cell and\n        # \"supercell\".\n\n        phonopy = Phonopy(self._struct.to_phonopy_atoms(), np.eye(3, 3))\n\n        # Construct a DynmatToForceConstants object to reverse transform\n        # the dynamical matrix to the corresponding force constants.\n\n        d2f = DynmatToForceConstants(phonopy.primitive, phonopy.supercell)\n\n        d2f.create_dynamical_matrices(\n            eigenvalues=[evals], eigenvectors=[evec_mat]\n        )\n\n        d2f.run()\n\n        fc2 = d2f.force_constants\n\n        # \"Flatten\" fc2 to a (3 n_a) x (3 n_a) matrix.\n\n        h = np.zeros((3 * n_a, 3 * n_a), dtype=np.float64)\n\n        for i_at in range(n_a):\n            i_fc2 = 3 * i_at\n\n            for j_at in range(n_a):\n                j_fc2 = 3 * j_at\n\n                h[i_fc2 : i_fc2 + 3, j_fc2 : j_fc2 + 3] = fc2[i_at, j_at]\n\n        return h\n\n    def to_dict(self):\n        \"\"\"Return the internal data as a dictionary of native Python\n        types for serialisation.\n\n        Returns\n        -------\n        d : dict\n            Dictionary structure containing internal data as native\n            Python types.\n        \"\"\"\n\n        lws = self._lws.tolist() if self._lws is not None else None\n        irreps = self._irreps.to_dict() if self._irreps is not None else None\n\n        return {\n            \"structure\": self._struct.to_dict(),\n            \"frequencies\": self._freqs.tolist(),\n            \"eigenvectors\": self._evecs.tolist(),\n            \"linewidths\": lws,\n            \"irreps\": irreps,\n        }\n\n    @staticmethod\n    def from_dict(d):\n        \"\"\"Create a new `GammaPhonons` instance from a dictionary\n        generated by `GammaPhonons.to_dict()`.\n\n        Parameters\n        ----------\n        d : dict\n            Dictionary generated by `to_dict()`.\n\n        Returns\n        -------\n        gamma_phonons : GammaPhonons\n            `GammaPhonons` object constructed from the data in `d`.\n        \"\"\"\n\n        irreps = None\n\n        if d[\"irreps\"] is not None:\n            irreps = Irreps.from_dict(d[\"irreps\"])\n\n        return GammaPhonons(\n            Structure.from_dict(d[\"structure\"]),\n            d[\"frequencies\"],\n            d[\"eigenvectors\"],\n            lws=d[\"linewidths\"],\n            irreps=irreps,\n        )\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.eigenvectors","title":"<code>eigenvectors</code>  <code>property</code>","text":"<p>numpy.ndarray : Phonon eigenvectors (shape: <code>(3N, N, 3)</code>).</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.frequencies","title":"<code>frequencies</code>  <code>property</code>","text":"<p>numpy.ndarray : Phonon frequencies (shape: <code>(3N,)</code>).</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.has_irreps","title":"<code>has_irreps</code>  <code>property</code>","text":"<p>bool : <code>True</code> if irredicuble representations (irreps) are available, otherwise <code>False</code>.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.has_linewidths","title":"<code>has_linewidths</code>  <code>property</code>","text":"<p>bool : <code>True</code> if linewidths are available, otherwise <code>False</code>.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.irreps","title":"<code>irreps</code>  <code>property</code>","text":"<p>Irreps or None : <code>Irreps</code> object with the point group and irrep symbols and indices of band groups.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.linewidths","title":"<code>linewidths</code>  <code>property</code>","text":"<p>numpy.ndarray or None : Phonon linewidths (shape: <code>(3N,)</code>).</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.num_modes","title":"<code>num_modes</code>  <code>property</code>","text":"<p>int : Number of modes.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Structure : Crystal structure.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.__init__","title":"<code>__init__(struct, freqs, evecs, lws=None, irreps=None)</code>","text":"<p>Create a new instance of the <code>GammaPhonons</code> class.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.__init__--parameters","title":"Parameters","text":"<p>struct : Structure     Crystal structure. freqs : array_like     Phonon frequencies in THz (shape: <code>(3N,)</code>). evecs : array_like     Phonon eigenvectors in mass-weighted units of sqrt(amu)     (shape: <code>(3N, N, 3)</code>). lws : array_like or None, optional     Phonon linewidths in THz (shape: <code>(3N,)</code>) or <code>None</code>. irreps : Irreps or None, optional     <code>Irreps</code> object specifying the point group and assigning     bands to irrep groups.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>def __init__(self, struct, freqs, evecs, lws=None, irreps=None):\n    r\"\"\"Create a new instance of the `GammaPhonons` class.\n\n    Parameters\n    ----------\n    struct : Structure\n        Crystal structure.\n    freqs : array_like\n        Phonon frequencies in THz (shape: `(3N,)`).\n    evecs : array_like\n        Phonon eigenvectors in mass-weighted units of sqrt(amu)\n        (shape: `(3N, N, 3)`).\n    lws : array_like or None, optional\n        Phonon linewidths in THz (shape: `(3N,)`) or `None`.\n    irreps : Irreps or None, optional\n        `Irreps` object specifying the point group and assigning\n        bands to irrep groups.\n    \"\"\"\n\n    n_a = struct.num_atoms\n\n    if n_a == 0:\n        raise ValueError(\n            'struct cannot be \"empty\" and must contain at least one atom.'\n        )\n\n    freqs = np_asarray_copy(freqs, dtype=np.float64)\n\n    if not np_check_shape(freqs, (3 * n_a,)):\n        raise ValueError(\"freqs must be an array_like with shape (3N,).\")\n\n    evecs = np_asarray_copy(evecs, dtype=np.float64)\n\n    if not np_check_shape(evecs, (3 * n_a, n_a, 3)):\n        raise ValueError(\n            \"evecs must be an array_like with shape (3N, N, 3).\"\n        )\n\n    # Eigenvectors are in general complex, but Gamma-point\n    # eigenvectors must be real.\n\n    if np.iscomplex(evecs).any():\n        if (np.abs(evecs.imag) &gt; ZERO_TOLERANCE).any():\n            raise ValueError(\"Gamma-point eigenvectors should be real.\")\n\n        evecs = evecs.real\n\n    if lws is not None:\n        lws = np_asarray_copy(lws, dtype=np.float64)\n\n        if not np_check_shape(lws, (3 * n_a,)):\n            raise ValueError(\n                \"If supplied, lws must be an array_like with shape (3N,).\"\n            )\n\n        if (lws &lt; 0.0).any():\n            raise ValueError(\"Linewidths cannot be negative.\")\n\n    if irreps is not None:\n        ir_band_inds_flat = irreps.band_indices_flat()\n\n        if len(ir_band_inds_flat) != 3 * n_a:\n            raise ValueError(\n                \"If supplied, irreps must assign all bands to \"\n                \"irrep groups.\"\n            )\n\n        if ir_band_inds_flat.max() &gt;= (3 * n_a):\n            raise RuntimeError(\n                \"One or more band indices in irreps are not \"\n                \"compatible with the number of modes in the \"\n                \"phonon calculation.\"\n            )\n\n    self._struct = struct\n    self._freqs = freqs\n    self._evecs = evecs\n    self._lws = lws\n    self._irreps = irreps\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.eigendisplacements","title":"<code>eigendisplacements()</code>","text":"<p>Return the phonon eigendisplacements (eigenvectors divided by sqrt(mass)).</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.eigendisplacements--returns","title":"Returns","text":"<p>edisps : numpy.ndarray     Eigendisplacements (shape: <code>(3N, N, 3)</code>).</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>def eigendisplacements(self):\n    r\"\"\"Return the phonon eigendisplacements (eigenvectors divided\n    by sqrt(mass)).\n\n    Returns\n    -------\n    edisps : numpy.ndarray\n        Eigendisplacements (shape: `(3N, N, 3)`).\n    \"\"\"\n\n    sqrt_m = np.sqrt(self._struct.atomic_masses)\n    return self._evecs / sqrt_m[np.newaxis, :, np.newaxis]\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.from_dict","title":"<code>from_dict(d)</code>  <code>staticmethod</code>","text":"<p>Create a new <code>GammaPhonons</code> instance from a dictionary generated by <code>GammaPhonons.to_dict()</code>.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.from_dict--parameters","title":"Parameters","text":"<p>d : dict     Dictionary generated by <code>to_dict()</code>.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.from_dict--returns","title":"Returns","text":"<p>gamma_phonons : GammaPhonons     <code>GammaPhonons</code> object constructed from the data in <code>d</code>.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>@staticmethod\ndef from_dict(d):\n    \"\"\"Create a new `GammaPhonons` instance from a dictionary\n    generated by `GammaPhonons.to_dict()`.\n\n    Parameters\n    ----------\n    d : dict\n        Dictionary generated by `to_dict()`.\n\n    Returns\n    -------\n    gamma_phonons : GammaPhonons\n        `GammaPhonons` object constructed from the data in `d`.\n    \"\"\"\n\n    irreps = None\n\n    if d[\"irreps\"] is not None:\n        irreps = Irreps.from_dict(d[\"irreps\"])\n\n    return GammaPhonons(\n        Structure.from_dict(d[\"structure\"]),\n        d[\"frequencies\"],\n        d[\"eigenvectors\"],\n        lws=d[\"linewidths\"],\n        irreps=irreps,\n    )\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.get_acoustic_mode_indices","title":"<code>get_acoustic_mode_indices()</code>","text":"<p>Return the band indices of the acoustic modes.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.get_acoustic_mode_indices--returns","title":"Returns","text":"<p>band_inds : numpy.ndarray     Band indices of the acoustic modes.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>def get_acoustic_mode_indices(self):\n    \"\"\"Return the band indices of the acoustic modes.\n\n    Returns\n    -------\n    band_inds : numpy.ndarray\n        Band indices of the acoustic modes.\n    \"\"\"\n\n    # If we have irreps, select irrep group(s) for which the\n    # average frequency is closest to f = 0 until we have chosen\n    # sufficient groups to cover three modes.\n\n    if self._irreps is not None:\n        ir_ave_freqs = [\n            np.mean(self._freqs[band_inds])\n            for band_inds in self._irreps.irrep_band_indices\n        ]\n\n        subset_band_inds = []\n\n        for _, band_inds in sorted(\n            zip(ir_ave_freqs, self._irreps.irrep_band_indices)\n        ):\n            subset_band_inds.extend(band_inds)\n\n            if len(subset_band_inds) == 3:\n                return np.array(subset_band_inds, dtype=int)\n\n        raise RuntimeError(\n            \"Unable to select a set of acoustic modes spanning \"\n            \"complete irrep groups. This may indicate an issue \"\n            \"with the phonon calculation.\"\n        )\n\n    # If not, find the three modes with frequencies closest to\n    # f = 0.\n\n    return np.argsort(np.abs(self._freqs))[:3]\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.hessian","title":"<code>hessian()</code>","text":"<p>Calculate the Hessian matrix (force constants) for the Gamma-point phonon modes.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.hessian--returns","title":"Returns","text":"<p>h : numpy.ndarray     Hessian in eV / Ang^2 (shape: <code>(3N, 3N)</code>).</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.hessian--notes","title":"Notes","text":"<p>This function requires the <code>phonopy</code> package.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>def hessian(self):\n    r\"\"\"Calculate the Hessian matrix (force constants) for the\n    Gamma-point phonon modes.\n\n    Returns\n    -------\n    h : numpy.ndarray\n        Hessian in eV / Ang^2 (shape: `(3N, 3N)`).\n\n    Notes\n    -----\n    This function requires the `phonopy` package.\n    \"\"\"\n\n    if not _PHONOPY_AVAILABLE:\n        raise RuntimeError(\n            \"GammaPhonons.hessian() requires the \"\n            \"phonopy.Phonopy and phonopy.phonon.DynmatToFc class.\"\n        )\n\n    n_a = self._struct.num_atoms\n\n    evals = np.copysign((self._freqs / VASP_TO_THZ) ** 2, self._freqs)\n\n    evec_mat = np.zeros((3 * n_a, 3 * n_a), dtype=np.complex128)\n\n    for i, evec in enumerate(self._evecs):\n        evec_mat[:, i].real = evec.flat\n\n    # Construct a Phonopy object to obtain the primitive cell and\n    # \"supercell\".\n\n    phonopy = Phonopy(self._struct.to_phonopy_atoms(), np.eye(3, 3))\n\n    # Construct a DynmatToForceConstants object to reverse transform\n    # the dynamical matrix to the corresponding force constants.\n\n    d2f = DynmatToForceConstants(phonopy.primitive, phonopy.supercell)\n\n    d2f.create_dynamical_matrices(\n        eigenvalues=[evals], eigenvectors=[evec_mat]\n    )\n\n    d2f.run()\n\n    fc2 = d2f.force_constants\n\n    # \"Flatten\" fc2 to a (3 n_a) x (3 n_a) matrix.\n\n    h = np.zeros((3 * n_a, 3 * n_a), dtype=np.float64)\n\n    for i_at in range(n_a):\n        i_fc2 = 3 * i_at\n\n        for j_at in range(n_a):\n            j_fc2 = 3 * j_at\n\n            h[i_fc2 : i_fc2 + 3, j_fc2 : j_fc2 + 3] = fc2[i_at, j_at]\n\n    return h\n</code></pre>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the internal data as a dictionary of native Python types for serialisation.</p>"},{"location":"reference/phonon/#phonopy_spectroscopy.phonon.GammaPhonons.to_dict--returns","title":"Returns","text":"<p>d : dict     Dictionary structure containing internal data as native     Python types.</p> Source code in <code>lib/phonopy_spectroscopy/phonon.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return the internal data as a dictionary of native Python\n    types for serialisation.\n\n    Returns\n    -------\n    d : dict\n        Dictionary structure containing internal data as native\n        Python types.\n    \"\"\"\n\n    lws = self._lws.tolist() if self._lws is not None else None\n    irreps = self._irreps.to_dict() if self._irreps is not None else None\n\n    return {\n        \"structure\": self._struct.to_dict(),\n        \"frequencies\": self._freqs.tolist(),\n        \"eigenvectors\": self._evecs.tolist(),\n        \"linewidths\": lws,\n        \"irreps\": irreps,\n    }\n</code></pre>"},{"location":"reference/structure/","title":"structure","text":"<p>Class and routines for storing and working with crystal structures.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure","title":"<code>Structure</code>","text":"Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>class Structure:\n    def __init__(\n        self,\n        latt_vecs,\n        at_pos,\n        at_typ,\n        at_m=None,\n        conv_trans=None,\n        cart_to_frac=False,\n    ):\n        \"\"\"Create a new instance of the `Structure` class.\n\n        Parameters\n        ----------\n        latt_vecs : array_like\n            Lattice vectors (shape: `(3, 3)`).\n        at_pos : array_like\n            Atomic positions (shape: `(N, 3)`).\n        at_typ : array_like\n            Atom types (shape: `(N,)`).\n        at_m : array_like, optional\n            Atomic masses (optional, shape: `(N,)`).\n        conv_trans : array_like, optional\n            Specifies a transformation to the conventonal unit cell\n            (default: identity matrix).\n        cart_to_frac : bool, optional\n            If `True`, convert `at_pos` from Cartesian to fractional\n            coordinates (default: `False`).\n        \"\"\"\n\n        latt_vecs = np_asarray_copy(latt_vecs, dtype=np.float64)\n\n        if not np_check_shape(latt_vecs, (3, 3)):\n            raise ValueError(\n                \"latt_vecs must be an array_like with shape (3, 3).\"\n            )\n\n        at_pos = np_asarray_copy(at_pos, dtype=np.float64)\n        at_typ = np.array([str(typ) for typ in at_typ], dtype=object)\n\n        if len(at_pos) &gt; 0 and not np_check_shape(at_pos, (None, 3)):\n            raise ValueError(\"at_pos must be an array_like with shape (N, 3).\")\n\n        n_a = len(at_pos)\n\n        if not np_check_shape(at_typ, (n_a,)):\n            raise ValueError(\"at_typ must be an array_like with shape (N,).\")\n\n        if at_m is None:\n            at_m = np.array(\n                [lookup_atomic_mass(sym) for sym in at_typ], dtype=np.float64\n            )\n\n            if (at_m &lt;= 0.0).any():\n                warnings.warn(\n                    \"Atomic mass lookup returned m &lt;= 0 for one or \"\n                    \"more atoms. The atomic masses likely need to be \"\n                    \"specified explicitly with the at_m keyword.\",\n                    RuntimeWarning,\n                )\n        else:\n            at_m = np_asarray_copy(at_m, dtype=np.float64)\n\n            if not np_check_shape(at_m, (n_a,)):\n                raise ValueError(\n                    \"If supplied, at_m must be an array_like with shape (N,).\"\n                )\n\n        if (at_m &lt;= 0.0).any():\n            raise ValueError(\"Atomic masses must be larger than zero.\")\n\n        if conv_trans is not None:\n            conv_trans = np_asarray_copy(conv_trans, dtype=np.float64)\n\n            if not np_check_shape(conv_trans, (3, 3)):\n                raise ValueError(\n                    \"If supplied, prim_trans must be an array_like \"\n                    \"with shape (3, 3).\"\n                )\n\n            # A valid transformation matrix to a conventional cell\n            # should have integer elements, although this may not be\n            # the case if the matrix has not been specified with\n            # sufficient precision.\n\n            abs_diff = np.abs(np.rint(conv_trans) - conv_trans)\n\n            if (abs_diff &gt; ZERO_TOLERANCE).any():\n                warnings.warn(\n                    \"One or more elements in conv_trans deviates from \"\n                    \"integer values by up to {0:.3e}. This could \"\n                    \"indicate an invalid tranformation matrix or \"\n                    \"insufficient precision.\".format(abs_diff.max()),\n                    UserWarning,\n                )\n        else:\n            conv_trans = np.identity(3, dtype=np.float64)\n\n        latt_vecs_conv = np.dot(conv_trans, latt_vecs)\n\n        if n_a &gt; 0:\n            if cart_to_frac:\n                at_pos = cartesian_to_fractional_coordinates(at_pos, latt_vecs)\n            else:\n                if (np.abs(at_pos) &gt; 1.0).any():\n                    warnings.warn(\n                        \"One or more of at_pos are outside the range \"\n                        \"[-1, 1] expected for fractional coordinates - \"\n                        \"use cart_to_frac=True to convert if needed.\",\n                        UserWarning,\n                    )\n\n        self._v_latt = latt_vecs\n        self._v_latt_conv = latt_vecs_conv\n\n        self._at_pos = at_pos\n        self._at_typ = at_typ\n        self._at_m = at_m\n\n        self._conv_trans = conv_trans\n\n    @property\n    def lattice_vectors(self):\n        \"\"\"numpy.ndarray : Lattice vectors (shape: `(3, 3)`).\"\"\"\n        return np_readonly_view(self._v_latt)\n\n    @property\n    def primitive_lattice_vectors(self):\n        \"\"\"numpy.ndarray : Lattive vectors of the primitive cell\n        (shape: `(3, 3)`, alias for `lattice_vectors`.\"\"\"\n        return self.lattice_vectors\n\n    @property\n    def conventional_lattice_vectors(self):\n        \"\"\"numpy.ndarray : Lattive vectors of the conventional cell\n        (shape: `(3, 3)`.\"\"\"\n        return np_readonly_view(self._v_latt_conv)\n\n    @property\n    def atom_positions(self):\n        \"\"\"numpy.ndarray : Atomic positions (shape: `(N, 3)`).\"\"\"\n        return np_readonly_view(self._at_pos)\n\n    @property\n    def atom_types(self):\n        \"\"\"numpy.ndarray : Atom types (shape: `(N,)`).\"\"\"\n        return np_readonly_view(self._at_typ)\n\n    @property\n    def atomic_masses(self):\n        \"\"\"numpy.ndarray : Atomic masses (shape: `(N,)`).\"\"\"\n        return np_readonly_view(self._at_m)\n\n    @property\n    def conventional_transformation_matrix(self):\n        \"\"\"numpy.ndarray : Transformation matrix to convert the\n        structure to its conventional cell.\"\"\"\n        return np_readonly_view(self._conv_trans)\n\n    @property\n    def num_atoms(self):\n        \"\"\"int : Number of atoms in the structure.\"\"\"\n        return self._at_pos.shape[0]\n\n    def volume(self, conv=False):\n        \"\"\"Calculate the unit-cell volume.\n\n        Parameters\n        ----------\n        conv : bool, optional\n            If `True`, return the volume of the conventional unit cell\n            (default: `False`).\n\n        Returns\n        -------\n        v : float\n            Unit-cell volume.\n        \"\"\"\n\n        v_1, v_2, v_3 = self._v_latt_conv if conv else self._v_latt\n        return np.dot(v_1, np.cross(v_2, v_3))\n\n    def reciprocal_lattice_vectors(self, conv=False):\n        \"\"\"Calculate and return the reciprocal lattice vectors.\n\n        Parameters\n        ----------\n        conv : bool, optional\n            If `True`, return the volume of the conventional unit cell\n            (default: `False`).\n\n        Returns\n        -------\n        recip_latt_vec : numpy.ndarray\n            Recipocal lattice vectors (shape: `(3, 3)`).\n        \"\"\"\n\n        a_1, a_2, a_3 = self._v_latt_conv if conv else self._v_latt\n        v = self.volume(conv=conv)\n\n        return np.array(\n            [\n                np.cross(a_2, a_3) / v,\n                np.cross(a_3, a_1) / v,\n                np.cross(a_1, a_2) / v,\n            ],\n            dtype=np.float64,\n        )\n\n    def real_space_normal(self, hkl, conv=False):\n        \"\"\"Calculate the real-space normal to the surface with Miller\n        index `hkl`.\n\n        Parameters\n        ----------\n        hkl : array_like\n            Integer Miller indices of the surface (shape: `(3,)`).,\n        conv : bool, optional\n            If `True`, return the volume of the conventional unit cell\n            (default: `False`).\n\n        Returns\n        -------\n        norm : numpy.ndarray\n            Real-space sufrace normal in Cartesian coordinates (shape:\n            `(3,)`).\n        \"\"\"\n\n        hkl = np.asarray(hkl)\n\n        if not np_check_shape(hkl, (3,)):\n            raise ValueError(\"hkl must be an array_like with shape `(3,)`.\")\n\n        b_1, b_2, b_3 = self.reciprocal_lattice_vectors(conv=conv)\n\n        # Use the reciprocal metric tensor to obtain the real-space\n        # normal in fractional coordinates.\n\n        recip_metric = np.array(\n            [\n                [np.dot(b_1, b_1), np.dot(b_1, b_2), np.dot(b_1, b_3)],\n                [np.dot(b_2, b_1), np.dot(b_2, b_2), np.dot(b_2, b_3)],\n                [np.dot(b_3, b_1), np.dot(b_3, b_2), np.dot(b_3, b_3)],\n            ]\n        )\n\n        norm_frac = np.dot(recip_metric, hkl)\n\n        norm_cart = fractional_to_cartesian_coordinates(\n            norm_frac, self._v_latt_conv if conv else self._v_latt\n        )\n\n        return norm_cart / np.linalg.norm(norm_cart)\n\n    def cartesian_positions(self):\n        \"\"\"Return the atomic positions converted to Cartesian\n        coordinates.\n\n        Returns\n        -------\n        pos_cart : numpy.ndarray\n            Atom positions in Cartesian coordinates (shape: `(N, 3)`).\n        \"\"\"\n\n        return fractional_to_cartesian_coordinates(self._at_pos, self._v_latt)\n\n    def to_phonopy_atoms(self):\n        \"\"\"Return the structure as a `PhonopyAtoms` instance.\n\n        Returns\n        -------\n        atoms : PhonopyAtoms\n            `PhonopyAtoms` object containing the structure data.\n\n        Notes\n        -----\n        This function requires the `phonopy` package.\n        \"\"\"\n\n        if not _PHONOPY_AVAILABLE:\n            raise RuntimeError(\n                \"Structure.to_phonopy_atoms() requires the \"\n                \"phonopy.structure.PhonopyAtoms class.\"\n            )\n\n        # The phonopy API uses the idiom \"if x\" to detect when a\n        # parameter x is set, which raises if x is a NumPy array with\n        # more than one element.\n\n        return PhonopyAtoms(\n            cell=self.lattice_vectors.tolist(),\n            scaled_positions=self.atom_positions.tolist(),\n            symbols=self.atom_types.tolist(),\n            masses=self.atomic_masses.tolist(),\n        )\n\n    def to_dict(self):\n        \"\"\"Return the internal data as a dictionary of native Python\n        types for serialisation.\n\n        Returns\n        -------\n        d : dict\n            Dictionary structure containing internal data as native\n            Python types.\n        \"\"\"\n\n        return {\n            \"lattice_vectors\": self._v_latt.tolist(),\n            \"atom_positions\": self._at_pos.tolist(),\n            \"atom_types\": list(self._at_typ),\n            \"atomic_masses\": self._at_m.tolist(),\n            \"conventional_transformation_matrix\": self._conv_trans.tolist(),\n        }\n\n    @staticmethod\n    def from_dict(d):\n        \"\"\"Create a new `Structure` instance from a dictionary\n        generated by `Structure.to_dict()`.\n\n        Parameters\n        ----------\n        d : dict\n            Dictionary generated by `to_dict()`.\n\n        Returns\n        -------\n        struct : Structure\n            `Structure` object constructed from the data in `d`.\n        \"\"\"\n\n        return Structure(\n            d[\"lattice_vectors\"],\n            d[\"atom_positions\"],\n            d[\"atom_types\"],\n            at_m=d[\"atomic_masses\"],\n            conv_trans=d[\"conventional_transformation_matrix\"],\n        )\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.atom_positions","title":"<code>atom_positions</code>  <code>property</code>","text":"<p>numpy.ndarray : Atomic positions (shape: <code>(N, 3)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.atom_types","title":"<code>atom_types</code>  <code>property</code>","text":"<p>numpy.ndarray : Atom types (shape: <code>(N,)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.atomic_masses","title":"<code>atomic_masses</code>  <code>property</code>","text":"<p>numpy.ndarray : Atomic masses (shape: <code>(N,)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.conventional_lattice_vectors","title":"<code>conventional_lattice_vectors</code>  <code>property</code>","text":"<p>numpy.ndarray : Lattive vectors of the conventional cell (shape: <code>(3, 3)</code>.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.conventional_transformation_matrix","title":"<code>conventional_transformation_matrix</code>  <code>property</code>","text":"<p>numpy.ndarray : Transformation matrix to convert the structure to its conventional cell.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.lattice_vectors","title":"<code>lattice_vectors</code>  <code>property</code>","text":"<p>numpy.ndarray : Lattice vectors (shape: <code>(3, 3)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.num_atoms","title":"<code>num_atoms</code>  <code>property</code>","text":"<p>int : Number of atoms in the structure.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.primitive_lattice_vectors","title":"<code>primitive_lattice_vectors</code>  <code>property</code>","text":"<p>numpy.ndarray : Lattive vectors of the primitive cell (shape: <code>(3, 3)</code>, alias for <code>lattice_vectors</code>.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.__init__","title":"<code>__init__(latt_vecs, at_pos, at_typ, at_m=None, conv_trans=None, cart_to_frac=False)</code>","text":"<p>Create a new instance of the <code>Structure</code> class.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.__init__--parameters","title":"Parameters","text":"<p>latt_vecs : array_like     Lattice vectors (shape: <code>(3, 3)</code>). at_pos : array_like     Atomic positions (shape: <code>(N, 3)</code>). at_typ : array_like     Atom types (shape: <code>(N,)</code>). at_m : array_like, optional     Atomic masses (optional, shape: <code>(N,)</code>). conv_trans : array_like, optional     Specifies a transformation to the conventonal unit cell     (default: identity matrix). cart_to_frac : bool, optional     If <code>True</code>, convert <code>at_pos</code> from Cartesian to fractional     coordinates (default: <code>False</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def __init__(\n    self,\n    latt_vecs,\n    at_pos,\n    at_typ,\n    at_m=None,\n    conv_trans=None,\n    cart_to_frac=False,\n):\n    \"\"\"Create a new instance of the `Structure` class.\n\n    Parameters\n    ----------\n    latt_vecs : array_like\n        Lattice vectors (shape: `(3, 3)`).\n    at_pos : array_like\n        Atomic positions (shape: `(N, 3)`).\n    at_typ : array_like\n        Atom types (shape: `(N,)`).\n    at_m : array_like, optional\n        Atomic masses (optional, shape: `(N,)`).\n    conv_trans : array_like, optional\n        Specifies a transformation to the conventonal unit cell\n        (default: identity matrix).\n    cart_to_frac : bool, optional\n        If `True`, convert `at_pos` from Cartesian to fractional\n        coordinates (default: `False`).\n    \"\"\"\n\n    latt_vecs = np_asarray_copy(latt_vecs, dtype=np.float64)\n\n    if not np_check_shape(latt_vecs, (3, 3)):\n        raise ValueError(\n            \"latt_vecs must be an array_like with shape (3, 3).\"\n        )\n\n    at_pos = np_asarray_copy(at_pos, dtype=np.float64)\n    at_typ = np.array([str(typ) for typ in at_typ], dtype=object)\n\n    if len(at_pos) &gt; 0 and not np_check_shape(at_pos, (None, 3)):\n        raise ValueError(\"at_pos must be an array_like with shape (N, 3).\")\n\n    n_a = len(at_pos)\n\n    if not np_check_shape(at_typ, (n_a,)):\n        raise ValueError(\"at_typ must be an array_like with shape (N,).\")\n\n    if at_m is None:\n        at_m = np.array(\n            [lookup_atomic_mass(sym) for sym in at_typ], dtype=np.float64\n        )\n\n        if (at_m &lt;= 0.0).any():\n            warnings.warn(\n                \"Atomic mass lookup returned m &lt;= 0 for one or \"\n                \"more atoms. The atomic masses likely need to be \"\n                \"specified explicitly with the at_m keyword.\",\n                RuntimeWarning,\n            )\n    else:\n        at_m = np_asarray_copy(at_m, dtype=np.float64)\n\n        if not np_check_shape(at_m, (n_a,)):\n            raise ValueError(\n                \"If supplied, at_m must be an array_like with shape (N,).\"\n            )\n\n    if (at_m &lt;= 0.0).any():\n        raise ValueError(\"Atomic masses must be larger than zero.\")\n\n    if conv_trans is not None:\n        conv_trans = np_asarray_copy(conv_trans, dtype=np.float64)\n\n        if not np_check_shape(conv_trans, (3, 3)):\n            raise ValueError(\n                \"If supplied, prim_trans must be an array_like \"\n                \"with shape (3, 3).\"\n            )\n\n        # A valid transformation matrix to a conventional cell\n        # should have integer elements, although this may not be\n        # the case if the matrix has not been specified with\n        # sufficient precision.\n\n        abs_diff = np.abs(np.rint(conv_trans) - conv_trans)\n\n        if (abs_diff &gt; ZERO_TOLERANCE).any():\n            warnings.warn(\n                \"One or more elements in conv_trans deviates from \"\n                \"integer values by up to {0:.3e}. This could \"\n                \"indicate an invalid tranformation matrix or \"\n                \"insufficient precision.\".format(abs_diff.max()),\n                UserWarning,\n            )\n    else:\n        conv_trans = np.identity(3, dtype=np.float64)\n\n    latt_vecs_conv = np.dot(conv_trans, latt_vecs)\n\n    if n_a &gt; 0:\n        if cart_to_frac:\n            at_pos = cartesian_to_fractional_coordinates(at_pos, latt_vecs)\n        else:\n            if (np.abs(at_pos) &gt; 1.0).any():\n                warnings.warn(\n                    \"One or more of at_pos are outside the range \"\n                    \"[-1, 1] expected for fractional coordinates - \"\n                    \"use cart_to_frac=True to convert if needed.\",\n                    UserWarning,\n                )\n\n    self._v_latt = latt_vecs\n    self._v_latt_conv = latt_vecs_conv\n\n    self._at_pos = at_pos\n    self._at_typ = at_typ\n    self._at_m = at_m\n\n    self._conv_trans = conv_trans\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.cartesian_positions","title":"<code>cartesian_positions()</code>","text":"<p>Return the atomic positions converted to Cartesian coordinates.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.cartesian_positions--returns","title":"Returns","text":"<p>pos_cart : numpy.ndarray     Atom positions in Cartesian coordinates (shape: <code>(N, 3)</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def cartesian_positions(self):\n    \"\"\"Return the atomic positions converted to Cartesian\n    coordinates.\n\n    Returns\n    -------\n    pos_cart : numpy.ndarray\n        Atom positions in Cartesian coordinates (shape: `(N, 3)`).\n    \"\"\"\n\n    return fractional_to_cartesian_coordinates(self._at_pos, self._v_latt)\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.from_dict","title":"<code>from_dict(d)</code>  <code>staticmethod</code>","text":"<p>Create a new <code>Structure</code> instance from a dictionary generated by <code>Structure.to_dict()</code>.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.from_dict--parameters","title":"Parameters","text":"<p>d : dict     Dictionary generated by <code>to_dict()</code>.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.from_dict--returns","title":"Returns","text":"<p>struct : Structure     <code>Structure</code> object constructed from the data in <code>d</code>.</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>@staticmethod\ndef from_dict(d):\n    \"\"\"Create a new `Structure` instance from a dictionary\n    generated by `Structure.to_dict()`.\n\n    Parameters\n    ----------\n    d : dict\n        Dictionary generated by `to_dict()`.\n\n    Returns\n    -------\n    struct : Structure\n        `Structure` object constructed from the data in `d`.\n    \"\"\"\n\n    return Structure(\n        d[\"lattice_vectors\"],\n        d[\"atom_positions\"],\n        d[\"atom_types\"],\n        at_m=d[\"atomic_masses\"],\n        conv_trans=d[\"conventional_transformation_matrix\"],\n    )\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.real_space_normal","title":"<code>real_space_normal(hkl, conv=False)</code>","text":"<p>Calculate the real-space normal to the surface with Miller index <code>hkl</code>.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.real_space_normal--parameters","title":"Parameters","text":"<p>hkl : array_like     Integer Miller indices of the surface (shape: <code>(3,)</code>)., conv : bool, optional     If <code>True</code>, return the volume of the conventional unit cell     (default: <code>False</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.real_space_normal--returns","title":"Returns","text":"<p>norm : numpy.ndarray     Real-space sufrace normal in Cartesian coordinates (shape:     <code>(3,)</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def real_space_normal(self, hkl, conv=False):\n    \"\"\"Calculate the real-space normal to the surface with Miller\n    index `hkl`.\n\n    Parameters\n    ----------\n    hkl : array_like\n        Integer Miller indices of the surface (shape: `(3,)`).,\n    conv : bool, optional\n        If `True`, return the volume of the conventional unit cell\n        (default: `False`).\n\n    Returns\n    -------\n    norm : numpy.ndarray\n        Real-space sufrace normal in Cartesian coordinates (shape:\n        `(3,)`).\n    \"\"\"\n\n    hkl = np.asarray(hkl)\n\n    if not np_check_shape(hkl, (3,)):\n        raise ValueError(\"hkl must be an array_like with shape `(3,)`.\")\n\n    b_1, b_2, b_3 = self.reciprocal_lattice_vectors(conv=conv)\n\n    # Use the reciprocal metric tensor to obtain the real-space\n    # normal in fractional coordinates.\n\n    recip_metric = np.array(\n        [\n            [np.dot(b_1, b_1), np.dot(b_1, b_2), np.dot(b_1, b_3)],\n            [np.dot(b_2, b_1), np.dot(b_2, b_2), np.dot(b_2, b_3)],\n            [np.dot(b_3, b_1), np.dot(b_3, b_2), np.dot(b_3, b_3)],\n        ]\n    )\n\n    norm_frac = np.dot(recip_metric, hkl)\n\n    norm_cart = fractional_to_cartesian_coordinates(\n        norm_frac, self._v_latt_conv if conv else self._v_latt\n    )\n\n    return norm_cart / np.linalg.norm(norm_cart)\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.reciprocal_lattice_vectors","title":"<code>reciprocal_lattice_vectors(conv=False)</code>","text":"<p>Calculate and return the reciprocal lattice vectors.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.reciprocal_lattice_vectors--parameters","title":"Parameters","text":"<p>conv : bool, optional     If <code>True</code>, return the volume of the conventional unit cell     (default: <code>False</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.reciprocal_lattice_vectors--returns","title":"Returns","text":"<p>recip_latt_vec : numpy.ndarray     Recipocal lattice vectors (shape: <code>(3, 3)</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def reciprocal_lattice_vectors(self, conv=False):\n    \"\"\"Calculate and return the reciprocal lattice vectors.\n\n    Parameters\n    ----------\n    conv : bool, optional\n        If `True`, return the volume of the conventional unit cell\n        (default: `False`).\n\n    Returns\n    -------\n    recip_latt_vec : numpy.ndarray\n        Recipocal lattice vectors (shape: `(3, 3)`).\n    \"\"\"\n\n    a_1, a_2, a_3 = self._v_latt_conv if conv else self._v_latt\n    v = self.volume(conv=conv)\n\n    return np.array(\n        [\n            np.cross(a_2, a_3) / v,\n            np.cross(a_3, a_1) / v,\n            np.cross(a_1, a_2) / v,\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the internal data as a dictionary of native Python types for serialisation.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.to_dict--returns","title":"Returns","text":"<p>d : dict     Dictionary structure containing internal data as native     Python types.</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return the internal data as a dictionary of native Python\n    types for serialisation.\n\n    Returns\n    -------\n    d : dict\n        Dictionary structure containing internal data as native\n        Python types.\n    \"\"\"\n\n    return {\n        \"lattice_vectors\": self._v_latt.tolist(),\n        \"atom_positions\": self._at_pos.tolist(),\n        \"atom_types\": list(self._at_typ),\n        \"atomic_masses\": self._at_m.tolist(),\n        \"conventional_transformation_matrix\": self._conv_trans.tolist(),\n    }\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.to_phonopy_atoms","title":"<code>to_phonopy_atoms()</code>","text":"<p>Return the structure as a <code>PhonopyAtoms</code> instance.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.to_phonopy_atoms--returns","title":"Returns","text":"<p>atoms : PhonopyAtoms     <code>PhonopyAtoms</code> object containing the structure data.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.to_phonopy_atoms--notes","title":"Notes","text":"<p>This function requires the <code>phonopy</code> package.</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def to_phonopy_atoms(self):\n    \"\"\"Return the structure as a `PhonopyAtoms` instance.\n\n    Returns\n    -------\n    atoms : PhonopyAtoms\n        `PhonopyAtoms` object containing the structure data.\n\n    Notes\n    -----\n    This function requires the `phonopy` package.\n    \"\"\"\n\n    if not _PHONOPY_AVAILABLE:\n        raise RuntimeError(\n            \"Structure.to_phonopy_atoms() requires the \"\n            \"phonopy.structure.PhonopyAtoms class.\"\n        )\n\n    # The phonopy API uses the idiom \"if x\" to detect when a\n    # parameter x is set, which raises if x is a NumPy array with\n    # more than one element.\n\n    return PhonopyAtoms(\n        cell=self.lattice_vectors.tolist(),\n        scaled_positions=self.atom_positions.tolist(),\n        symbols=self.atom_types.tolist(),\n        masses=self.atomic_masses.tolist(),\n    )\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.volume","title":"<code>volume(conv=False)</code>","text":"<p>Calculate the unit-cell volume.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.volume--parameters","title":"Parameters","text":"<p>conv : bool, optional     If <code>True</code>, return the volume of the conventional unit cell     (default: <code>False</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.Structure.volume--returns","title":"Returns","text":"<p>v : float     Unit-cell volume.</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def volume(self, conv=False):\n    \"\"\"Calculate the unit-cell volume.\n\n    Parameters\n    ----------\n    conv : bool, optional\n        If `True`, return the volume of the conventional unit cell\n        (default: `False`).\n\n    Returns\n    -------\n    v : float\n        Unit-cell volume.\n    \"\"\"\n\n    v_1, v_2, v_3 = self._v_latt_conv if conv else self._v_latt\n    return np.dot(v_1, np.cross(v_2, v_3))\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.cartesian_to_fractional_coordinates","title":"<code>cartesian_to_fractional_coordinates(cart_pos, latt_vecs)</code>","text":"<p>Convert positions from Cartesian to fractional coordinates.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.cartesian_to_fractional_coordinates--parameters","title":"Parameters","text":"<p>cart_pos : array_like     Atom position or set of positions in Cartesian coordinates     (shape: <code>(3,)</code> or <code>(N, 3)</code>). latt_vecs : array_like     Lattice vectors (shape: <code>(3, 3)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.cartesian_to_fractional_coordinates--returns","title":"Returns","text":"<p>frac_pos : numpy.ndarray     Atom positions in fractional coordinates (same shape as     <code>cart_pos</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def cartesian_to_fractional_coordinates(cart_pos, latt_vecs):\n    \"\"\"Convert positions from Cartesian to fractional coordinates.\n\n    Parameters\n    ----------\n    cart_pos : array_like\n        Atom position or set of positions in Cartesian coordinates\n        (shape: `(3,)` or `(N, 3)`).\n    latt_vecs : array_like\n        Lattice vectors (shape: `(3, 3)`).\n\n    Returns\n    -------\n    frac_pos : numpy.ndarray\n        Atom positions in fractional coordinates (same shape as\n        `cart_pos`).\n    \"\"\"\n\n    cart_pos, n_dim_add = np_expand_dims(np.asarray(cart_pos), (None, 3))\n\n    latt_vecs = np.asarray(latt_vecs)\n\n    if not np_check_shape(latt_vecs, (3, 3)):\n        raise ValueError(\"latt_vecs must be an array_like with shape (3, 3).\")\n\n    trans_mat = np.linalg.inv(latt_vecs)\n\n    frac_pos = np.zeros_like(cart_pos)\n\n    for i, p in enumerate(cart_pos):\n        frac_pos[i] = np.dot(p, trans_mat) % 1.0\n\n    return frac_pos if n_dim_add == 0 else frac_pos[0]\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.fractional_to_cartesian_coordinates","title":"<code>fractional_to_cartesian_coordinates(frac_pos, latt_vecs)</code>","text":"<p>Convert positions from fractional to Cartesian coordinates.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.fractional_to_cartesian_coordinates--parameters","title":"Parameters","text":"<p>frac_pos : array_like     Atom position or set of positions in fractional coordinates     (shape: <code>(3,)</code> or <code>(N, 3)</code>). latt_vecs : array_like     Lattice vectors (shape: <code>(3, 3)</code>).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.fractional_to_cartesian_coordinates--returns","title":"Returns","text":"<p>cart_pos : numpy.ndarray     Atom positions in Cartesian coordinates (same shape as     <code>frac_pos</code>).</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def fractional_to_cartesian_coordinates(frac_pos, latt_vecs):\n    \"\"\"Convert positions from fractional to Cartesian coordinates.\n\n    Parameters\n    ----------\n    frac_pos : array_like\n        Atom position or set of positions in fractional coordinates\n        (shape: `(3,)` or `(N, 3)`).\n    latt_vecs : array_like\n        Lattice vectors (shape: `(3, 3)`).\n\n    Returns\n    -------\n    cart_pos : numpy.ndarray\n        Atom positions in Cartesian coordinates (same shape as\n        `frac_pos`).\n    \"\"\"\n\n    frac_pos, n_dim_add = np_expand_dims(np.asarray(frac_pos), (None, 3))\n\n    latt_vecs = np.asarray(latt_vecs)\n\n    if not np_check_shape(latt_vecs, (3, 3)):\n        raise ValueError(\"latt_vecs must be an array_like with shape (3, 3).\")\n\n    cart_pos = np.zeros_like(frac_pos)\n\n    for i, p in enumerate(frac_pos):\n        cart_pos[i] = np.dot(p.T, latt_vecs)\n\n    return cart_pos if n_dim_add == 0 else cart_pos[0]\n</code></pre>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.lookup_atomic_mass","title":"<code>lookup_atomic_mass(symbol)</code>","text":"<p>Lookup an atomic mass from an atomic symbol.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.lookup_atomic_mass--parameters","title":"Parameters","text":"<p>symbol : str     Atomic symbol.</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.lookup_atomic_mass--returns","title":"Returns","text":"<p>m : float     Atomic mass (amu).</p>"},{"location":"reference/structure/#phonopy_spectroscopy.structure.lookup_atomic_mass--notes","title":"Notes","text":"<p>This function requires the <code>phonopy</code> package.</p> Source code in <code>lib/phonopy_spectroscopy/structure.py</code> <pre><code>def lookup_atomic_mass(symbol):\n    \"\"\"Lookup an atomic mass from an atomic symbol.\n\n    Parameters\n    ----------\n    symbol : str\n        Atomic symbol.\n\n    Returns\n    -------\n    m : float\n        Atomic mass (amu).\n\n    Notes\n    -----\n    This function requires the `phonopy` package.\n    \"\"\"\n\n    if not _PHONOPY_AVAILABLE:\n        raise RuntimeError(\n            \"lookup_atomic_mass() requires the \"\n            \"phonopy.atoms.atom_data attribute.\"\n        )\n\n    symbol = str(symbol).title()\n\n    for _, db_symbol, _, db_mass in atom_data:\n        if symbol == db_symbol:\n            return db_mass\n\n    raise ValueError(\n        'Data for symbol=\"{0}\" not available in '\n        \"phonopy.atoms.atom_data.\".format(symbol)\n    )\n</code></pre>"},{"location":"tutorials/benzene_derivatives_tutorial/","title":"Example: Benzene Derivatives","text":"<p>As a simple test of the infrared (IR) calculation routines, we compare simulated IR spectra of benzene and several derivatives to high-quality gas-phase spectra from the NIST Chemistry WebBook.[1]</p>"},{"location":"tutorials/benzene_derivatives_tutorial/#calculations","title":"Calculations","text":"<p>For these calculations, we used Phonopy and VASP to prepare phonon frequencies/eigenvectors and Born effective-charge tensors, and post-processed using the <code>phonopy-ir</code> script.</p> <p>Molecular models were prepared in Avogadro[2] and optimised in large periodic simulation cells with ~15 \u212b between periodic images (built using the <code>xyz2poscar</code> script).</p> <p>DFT calculations were performed with the dispersion-corrected PBE-D3 functional, an 800 eV plane-wave cutoff, and the \"standard\" H, C, N and O pseudopotentials (i.e. <code>POTCAR_H</code>, <code>POTCAR_C</code>, <code>POTCAR_N</code> and <code>POTCAR_O</code>) from the VASP 5.4 PAW dataset.</p> <p>For the finite-displacement calculations with Phonopy, we used the default 1 \u00d7 10<sup>-2</sup> \u212b displacement step. For a subset of the molecules we also tested a smaller 5 \u00d7 10<sup>-3</sup> \u212b step. The Born effective-charge tensors were calculated using the DFPT routines in VASP (i.e. with the <code>LEPSILON</code> tag).</p> <p>To prepare the phonon frequencies and eigenvectors:</p> <ol> <li> <p>Create displacements: <code>phonopy -d --dim=\"1 1 1\"</code> (for a 5 \u00d7 10<sup>-3</sup> \u212b dispacement step, add <code>--amplitude=0.005</code>)</p> </li> <li> <p>Run single-point force calculations (sample VASP input files in the VASP-Files folder)</p> </li> <li> <p>Collect forces: <code>phonopy -f vasprun-{1..X}.xml</code></p> </li> <li> <p>Generate a <code>mesh.yaml</code> file containing the structure and \u0393-point phonon frequencies and eigenvectors: <code>phonopy --dim=\"1 1 1\" --fc-symmetry --mesh=\"1 1 1\" --eigenvectors</code> (structures can also be read from a <code>phonopy.yaml</code> or VASP 5.x-format <code>POSCAR</code> file); for older versions of Phonopy, you may need to use <code>--fc_symmetry=1</code> instead of <code>--fc-symmetry</code></p> </li> </ol> <p>To prepare the Born effective-charge tensors:</p> <ol> <li> <p>Run a VASP DFPT calculation on the optimised structure to calculate the Born charges and dielectric tensor (sample VASP input files in VASP-Files)</p> </li> <li> <p>Create a <code>BORN</code> file using the Phonopy <code>outcar-born</code> script: <code>outcar-born &gt; BORN</code></p> </li> </ol> <p>Finally, to generate the spectrum:</p> <ol> <li>Run <code>phonopy-ir</code> with a nominal spectral linewidth and spectrum range: <code>phonopy-ir --linewidth=16.5 --spectrum_range=\"500 4000\"</code></li> </ol>"},{"location":"tutorials/benzene_derivatives_tutorial/#results","title":"Results","text":""},{"location":"tutorials/benzene_derivatives_tutorial/#a-benzene","title":"a. Benzene","text":"<ul> <li>Raw data: Benzene; CAS/NIST database ID: 71-43-2</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#b-phenol","title":"b. Phenol","text":"<ul> <li>Raw data: Phenol; CAS/NIST database ID: 108-95-2</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#c-toluene","title":"c. Toluene","text":"<ul> <li>Raw data: Toluene; CAS/NIST database ID: 108-88-3</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#d-anisole","title":"d. Anisole","text":"<ul> <li>Raw data: Anisole; CAS/NIST database ID: 100-66-3</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#e-aniline","title":"e. Aniline","text":"<ul> <li>Raw data: Aniline; CAS/NIST database ID: 62-53-3</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#f-benzoic-acid","title":"f. Benzoic acid","text":"<ul> <li>Raw data: Benzoic acid; CAS/NIST database ID: 65-85-0</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#g-benzaldehyde","title":"g. Benzaldehyde","text":"<ul> <li>Raw data: Benzaldehyde; CAS/NIST database ID: 100-52-7</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#h-benzonitrile","title":"h. Benzonitrile","text":"<ul> <li>Raw data: Benzonitrile; CAS/NIST database ID: 100-47-0</li> </ul>"},{"location":"tutorials/benzene_derivatives_tutorial/#references","title":"References","text":"<ol> <li>http://webbook.nist.gov/</li> <li>https://avogadro.cc/</li> </ol>"},{"location":"tutorials/overview/","title":"Phonopy Spectroscopy Tutorials","text":""},{"location":"tutorials/overview/#benzene-derivatives","title":"Benzene Derivatives","text":"<p>In this tutorial, we compare simulated IR spectra of benzene and several derivatives to high-quality gas-phase spectra from the NIST Chemistry WebBook.</p>"},{"location":"tutorials/overview/#-sio2","title":"\u03b1-SiO2","text":"<p>In this tutorial, we perform a detailed simulation of the infrared (IR) and Raman spectra of \u03b1-SiO2 (quartz) in the P3221 spacegroup.</p>"},{"location":"tutorials/overview/#test","title":"Test","text":"<p>In this tutorial, we are checking that a Jupyter Notebook is compiled correctly.</p>"},{"location":"tutorials/test_tutorial/","title":"test notebook","text":"<p>We can write things about how to use the code</p> In\u00a0[2]: Copied! <pre>2+2 \n</pre> 2+2  Out[2]: <pre>4</pre> <p>And insert code blocks demonstrating its usage</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/test_tutorial/#test-notebook","title":"test notebook\u00b6","text":""}]}