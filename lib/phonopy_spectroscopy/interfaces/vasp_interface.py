# -*- coding: utf-8 -*-


# ---------
# Docstring
# ---------


"""Routines for interfacing with the Vienna Ab initio Simulation Package
(VASP) code."""


# -------
# Imports
# -------


import warnings

import xml.etree.ElementTree as ET

import numpy as np

from ..constants import ZERO_TOLERANCE
from ..structure import Structure


# ------------
# POSCAR Files
# ------------


def structure_from_poscar(file_path):
    """Read a structure from a VASP POSCAR file and return a `Structure`
    object,

    Parameters
    ----------
    file_path : str
        File path.

    Returns
    -------
    struct : Structure
        `Structure` object containing the structure.

    Notes
    -----
    This function supports a subset of the POSCAR format common to the
    most recent versions of VASP. In particular, it does not support
    the following:

    * Specification of the cell volume with a negative scale factor.
    * Files generated by VASP < 5 without atom types
    """

    with open(file_path, "r") as f:
        # Line 1: system name.

        next(f)

        # Line 2: sScale factor.

        s_f = float(next(f).strip())

        if s_f < 0.0:
            raise RuntimeError(
                "POSCAR file {0}: Speficiation of the cell volume with "
                "a negative scaling factor is currently not supported."
                "".format(file_path)
            )

        # Lines 3-5: lattice vectors.

        v_latt = [
            [float(v) for v in next(f).strip().split()[:3]] for _ in range(3)
        ]

        v_latt = s_f * np.array(v_latt, dtype=np.float64)

        if np.isclose(np.linalg.norm(v_latt, axis=0), ZERO_TOLERANCE).any():
            raise RuntimeError(
                "POSCAR file {0}: One or more lattice vectors has zero "
                "length.".format(file_path)
            )

        # Lines 6/7: atom types and counts.

        at_syms = next(f).strip().split()
        at_cnts = [int(item) for item in next(f).strip().split()]

        if len(at_syms) != len(at_cnts):
            raise RuntimeError(
                "POSCAR file {0}: Numbers of atomic symbols and atom "
                "counts on Line 6/7 do not match.".format(file_path)
            )

        # The Structure constructor requires a "flat" list of atomic
        # symbols.

        at_typs = []

        for sym, cnt in zip(at_syms, at_cnts):
            at_typs += [sym] * cnt

        # Line 8(/9): optional selective dynamics keyword and
        # cartesian/"direct" (fractional) coordinate specification.

        key = next(f).strip()[0].lower()

        if key == "s":
            # Selective dynamics keyword -> coordinate specification on
            # the following line.

            key = next(f).strip()[0].lower()

        # The POSCAR format specification says that "c" or "k" are
        # interpreted as Cartesian coordinates, and anything else as
        # fractional coordinates.

        is_cart = key in ("c", "k")

        # Following N lines: atomic positions.

        at_pos = []

        for _ in range(len(at_typs)):
            at_pos.append([float(v) for v in next(f).strip().split()[:3]])

        at_pos = np.array(at_pos, dtype=np.float64)

        if is_cart:
            at_pos *= s_f

        # Build and return a Structure object.

        return Structure(v_latt, at_pos, at_typs, cart_to_frac=is_cart)


def structure_to_poscar(
    struct, file_path, system_name="Generated by Phonopy-Spectroscopy"
):
    """Write a `Structure` object to a VASP POSCAR file.

    Parameters
    ----------
    struct : Structure
        Structure.
    file_path : str
        File path.
    system_name : str, optional
        System name to write to Line 1 of the POSCAR file (default:
        `"Generated by Phonopy-Spectroscopy"`).
    """

    if struct.num_atoms == 0:
        raise ValueError("Cannot write an empty structure to a POSCAR file.")

    with open(file_path, "w") as f:
        # Line 1: system name.

        f.write(system_name + "\n")

        # Line 2: scale factor.

        f.write("  {0: >19.16f}\n".format(1.0))

        # Lines 3-5: lattice vectors.

        for v in struct.lattice_vectors:
            f.write("  {0: >21.16f}  {1: >21.16f}  {2: >21.16f}\n".format(*v))

        # Group atom positions by symbol.

        at_syms, at_cnts = [], []

        at_sym_tmp = struct.atom_types[0]
        at_cnt_tmp = 1

        for at_sym in struct.atom_types[1:]:
            if at_sym == at_sym_tmp:
                at_cnt_tmp += 1
            else:
                at_syms.append(at_sym_tmp)
                at_cnts.append(at_cnt_tmp)

                at_sym_tmp = at_sym
                at_cnt_tmp = 1

        at_syms.append(at_sym_tmp)
        at_cnts.append(at_cnt_tmp)

        # Lines 6/7: atom symbols and counts.

        f.write("  ".join(["{0: >3}".format(s) for s in at_syms]) + "\n")
        f.write("  ".join(["{0: >2}".format(c) for c in at_cnts]) + "\n")

        # Line 8: coordinate-type specifier.

        f.write("Direct\n")

        for p in struct.atom_positions:
            f.write("  {0: >21.16f}  {1: >21.16f}  {2: >21.16f}\n".format(*p))


# -----------------
# vasprun.xml files
# -----------------


def _parse_dielectric_constant(file_path, parent):
    """Parse a dielectric constant in a vasprun.xml file.

    Parameters
    ----------
    file_path : str
        vasprun.xml file being read (used for error messages).
    parent : xml.etree.ElementTree.Element
        XML node containing a dielectric constant.

    Returns
    -------
    eps : numpy.ndarray
        Dielectric constant (shape: `(3, 3)`).
    """

    elements = parent.findall("./v")

    if len(elements) != 3:
        raise RuntimeError(
            "vasprun.xml file {0}: Unexpected number of vectors in "
            "dielectric constant element.".format(file_path)
        )

    return np.array(
        [[float(v) for v in e.text.strip().split()] for e in elements],
        dtype=np.float64,
    )


def _parse_dielectric_function(file_path, parent):
    """Parse a dielectric function in a vasprun.xml file.

    Parameters
    ----------
    file_path : str
        vasprun.xml file being read (used for error messages).
    parent : xml.etree.ElementTree.Element
        XML node containing a dielectric function.

    Returns
    -------
    eps : tuple of numpy.ndarray
        Tuple of `(e, eps_e)` containing a complex dielectric function
        (shapes: `(N,)`, `(N, 3, 3)`).
    """
    # We should have real and imaginary parts containing arrays of
    # values.

    eps_re = parent.findall("./real/array")
    eps_im = parent.findall("./imag/array")

    if len(eps_re) != 1 or len(eps_im) != 1:
        raise RuntimeError(
            "vasprun.xml file {0}: Multiple or missing real/imag child "
            "elements in parent dielectric function element.".format(file_path)
        )

    eps_re, eps_im = eps_re[0], eps_im[0]

    # Check field names are as expected.

    for arr in eps_re, eps_im:
        fields = arr.findall("./field")

        for f, h in zip(
            fields, ["energy", "xx", "yy", "zz", "xy", "yz", "zx"]
        ):
            if f.text != h:
                raise RuntimeError(
                    "vasprun.xml file {0}: Unexpected column headings "
                    "in dielectric function arrays.".format(file_path)
                )

    # Check the real and imaginary parts have the same number of rows
    # and that both have at least one row.

    eps_re_rows = eps_re.findall("./set/r")
    eps_im_rows = eps_im.findall("./set/r")

    if len(eps_im_rows) != len(eps_re_rows) or len(eps_re_rows) == 0:
        raise RuntimeError(
            "vasprun.xml file {0}: Real/imaginary dielectric function "
            "arrays of unequal or zero length.".format(file_path)
        )

    eps_re = np.array(
        [[float(v) for v in r.text.strip().split()] for r in eps_re_rows],
        dtype=np.float64,
    )

    eps_im = np.array(
        [[float(v) for v in r.text.strip().split()] for r in eps_im_rows],
        dtype=np.float64,
    )

    # Check real and imaginary parts are on the same energy axis.

    if not np.allclose(eps_re[:, 0], eps_im[:, 0]):
        raise RuntimeError(
            "vasprun.xml file {0}: Real/imaginary dielectric function "
            "arrays have different energy axes.".format(file_path)
        )

    # Extract energies.

    e = eps_re[:, 0]

    # Combine the real and imaginary parts to generate complex
    # dielectric function.

    eps_e = np.zeros((len(e), 3, 3), dtype=np.complex128)

    for idx, (idy, idz) in enumerate(
        [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (2, 0)]
    ):
        eps_e.real[:, idy, idz] = eps_re[:, idx + 1]
        eps_e.imag[:, idy, idz] = eps_im[:, idx + 1]

    eps_e[:, 1, 0] = eps_e[:, 0, 1]
    eps_e[:, 2, 1] = eps_e[:, 1, 2]
    eps_e[:, 0, 2] = eps_e[:, 2, 0]

    return (e, eps_e)


def dielectric_from_vasprun_xml(
    file_path, response_func_type="d-d", response_func_idx=0
):
    """Read high-frequency dielectric constants or energy-dependent
    dielectric functions from a vasprun.xml file.

    Parameters
    ----------
    file_path : str
        File path.
    response_func_type : {"d-d", "c-c"}, optional
        For energy-dependent response functions, sets which type of
        response function to return: density-density (`"d-d"`) or
        current-current (`"c-c"`) (default: `"d-d"`).
    response_func_idx : int, optional
        For vasprun.xml files where response functions are not tagged
        with comments indicating the type, specifies the zero-based
        index of the function to return (default: 0).

    Returns
    -------
    dielectrics : tuple of numpt.ndarray
        Extracted dielectric constant/function as a tuple of
        `(e, eps)` with shape `(N,)` and `(N, 3, 3)`. For a
        high-frequency dielectric constant calculation, the energy is
        assumed to be E = 0.
    """

    tree = ET.parse(file_path)
    root = tree.getroot()

    # Look for (single) high-frequency dielectric constants. Depending
    # on the type of calculation, there may be multiple values. The code
    # below is designed so that the last one written to the file is
    # returned, which is usually what we want.

    eps_hf = None

    xpath_strs = [
        # DFPT with LEPSILON = .TRUE.
        './calculation/varray[@name="dielectric_ipa"]',
        './calculation/varray[@name="dielectric_dft"]',
        './calculation/varray[@name="epsilon"]',
        # Finite field with LCALCEPS = .TRUE.
        './calculation/varray[@name="epsilon_scf"]',
        './calculation/varray[@name="dielectric_scf"]',
    ]

    for xpath_str in xpath_strs:
        elements = root.findall(xpath_str)

        if len(elements) > 0:
            if len(elements) == 1:
                eps_hf = _parse_dielectric_constant(file_path, elements[0])
            else:
                raise RuntimeError(
                    "vasprun.xml file {0}: Multiple high-frequency "
                    "dielectric constant calculations of the same "
                    "type.".format(file_path)
                )

    if eps_hf is not None:
        return (
            np.array([0.0], dtype=np.float64),
            np.array([eps_hf], dtype=np.float64),
        )

    # Look for frequency-dependent dielectric function calculations.
    # Depending on the calculations there may be "density-density" and
    # "current-current" response functions. Which of these is returned
    # is set by an optional argument that defaults to the former.

    elements = root.findall("./calculation/dielectricfunction")

    for element in elements:
        if "comment" in element.attrib:
            if (
                element.attrib["comment"] == "density-density"
                and response_func_type == "d-d"
            ):
                return _parse_dielectric_function(file_path, element)

            if (
                element.attrib["comment"] == "current-current"
                and response_func_type == "c-c"
            ):
                return _parse_dielectric_function(file_path, element)

    # In some vasprun.xml files, the response functions are not tagged
    # with comments indicating their type. In this case, select based
    # on the index specified by response_func_idx.

    if len(elements) > 0:
        if response_func_idx < len(elements):
            return _parse_dielectric_function(
                file_path, elements[response_func_idx]
            )
        else:
            raise RuntimeError(
                "vasprun.xml file {0} : response_func_idx={1} is not "
                "compatible with the number of dielectric functions "
                "found in the file ({2}).".format(
                    file_path, response_func_idx, len(elements)
                )
            )

    raise RuntimeError(
        "vasprun.xml file {0} : No dielectric constants/functions "
        "found. This may be because the type of calculation is not "
        "currently supported.".format(file_path)
    )
